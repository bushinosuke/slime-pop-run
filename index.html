<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Slime Pop Run</title>
<style>
  html, body { margin:0; height:100%; background:#f6fbff; font-family: system-ui, -apple-system, "Segoe UI", Roboto; }
  #wrap { display:flex; flex-direction:column; height:100%; }
  #hud {
    display:flex; gap:16px; align-items:center; justify-content:space-between;
    padding:10px 14px; background:linear-gradient(180deg,#ffffffaa,#ffffff66);
    backdrop-filter: blur(6px); position:relative; z-index:2; box-shadow: 0 2px 8px #00000010;
  }
  #hud .stat { font-weight:700; color:#5a6a7a; font-size:14px; }
  #game { flex:1; position:relative; }
  canvas { width:100%; height:100%; display:block; background:linear-gradient(#ccf2ff,#f5f9ff 60%); }
  #msg {
    position:absolute; left:50%; top:20px; transform:translateX(-50%);
    background:#ffffffd8; border-radius:12px; padding:8px 12px; color:#445; font-weight:700;
    box-shadow:0 4px 12px #00000015; z-index:2; user-select: none;
  }
  /* ãƒ¢ãƒã‚¤ãƒ«ç”¨ã‚½ãƒ•ãƒˆãƒœã‚¿ãƒ³ */
  #controls {
    position:absolute; left:0; right:0; bottom:8px; z-index:3; display:flex; justify-content:space-between; padding:0 10px; pointer-events:none;
  }
  .pad {
    display:flex; gap:10px; pointer-events:auto;
  }
  .btn {
    width:64px; height:64px; border-radius:16px; background:#ffffffbb;
    border:2px solid #bfe9ff; box-shadow:0 4px 10px #00000020; touch-action:none;
    display:grid; place-items:center; user-select:none; font-weight:800; color:#69a; backdrop-filter: blur(6px);
  }
  .btn:active { transform: translateY(2px); }
  @media (min-width: 900px) {
    #controls { display:none; }
  }
</style>
</head>
<body>
<div id="wrap">
  <div id="hud">
    <div class="stat" id="score">â˜… 0</div>
    <div class="stat" id="tips">æ“ä½œï¼šâ†“ ä½é€Ÿ / â†‘ or Space ã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆäºŒæ®µã¾ã§ï¼‰ / R ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</div>
    <div class="stat" id="lives">â™¥ 3</div>
  </div>
  <div id="game">
    <div id="msg">ã‚´ãƒ¼ãƒ«ã®æ——ã¾ã§é€²ã‚‚ã†ï¼ ã‚³ã‚¤ãƒ³ã‚’é›†ã‚ã¦ã‚¹ã‚³ã‚¢UP</div>
    <canvas id="cv" width="960" height="540" aria-label="Slime Pop Run"></canvas>
    <div id="controls" aria-hidden="false">
      <div class="pad">
        <div class="btn" data-slow>â–¼</div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== å¯æ„›ã„é…è‰² =====
  const COLORS = {
    skyTop: '#ccf2ff', skyBottom: '#f5f9ff',
    ground: '#ffd8e1', block: '#ffeef5',
    blockEdge: '#ffb3c7',
    spike: '#ff8e9e',
    coin: '#ffd66e',
    flag: '#9ad7ff',
    flagPole: '#8bc5ff',
    slimeBody: '#7fd8ff',
    slimeBelly: '#bff0ff',
    slimeEye: '#2a3b4c',
    enemy: '#ffb1f3',
    enemyEdge: '#ff80e8',
    text: '#4c5d70'
  };

  // ===== å…¥åŠ›ç®¡ç† =====
  const keys = { slow:false, up:false };
  const onKey = (e, down) => {
    switch (e.code) {
      case 'ArrowDown': case 'KeyS':
        keys.slow = down; break;
      case 'ArrowUp': case 'Space': case 'KeyW': if (down) keys.up=true; break;
      case 'KeyR': if (down) resetLevel(); break;
    }
    if (['ArrowDown','ArrowUp','Space'].includes(e.code)) e.preventDefault();
  };
  addEventListener('keydown', e=>onKey(e,true));
  addEventListener('keyup',   e=>onKey(e,false));

  // ã‚¿ãƒƒãƒãƒœã‚¿ãƒ³
  const bindHold = (el, setter) => {
    const on = (ev) => { ev.preventDefault(); setter(true); };
    const off= (ev) => { ev.preventDefault(); setter(false); };
    el.addEventListener('pointerdown', on);
    addEventListener('pointerup', off);
    addEventListener('pointercancel', off);
    addEventListener('pointerleave', off);
  };
  bindHold(document.querySelector('[data-slow]'), v=>keys.slow=v);

  // ç”»é¢ã®ã©ã“ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ã‚‚ã‚¸ãƒ£ãƒ³ãƒ—
  document.getElementById('game').addEventListener('pointerdown', e => {
    if (!e.target.closest('.btn')) {
      e.preventDefault();
      keys.up = true;
    }
  });

  // ===== ã‚­ãƒ£ãƒ³ãƒã‚¹ =====
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = cv.clientWidth, h = cv.clientHeight;
    cv.width = Math.round(w * dpr);
    cv.height= Math.round(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', resize); resize();

  // ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const sign = (v)=> v<0?-1: v>0?1:0;

  // ===== ã‚¿ã‚¤ãƒ«ãƒãƒƒãƒ— =====
  // è¨˜å·: #=ãƒ–ãƒ­ãƒƒã‚¯, ^=ãƒˆã‚², .=ç©º, o=ã‚³ã‚¤ãƒ³, e=æ•µ, S=ã‚¹ã‚¿ãƒ¼ãƒˆ, F=ã‚´ãƒ¼ãƒ«
  let LEVEL = [];
  const TILE = 32;
  let mapH = 0;
  let mapW = 0;

  function generateLevel(width = 90, height = 20){
    const grid = Array.from({length: height}, () => Array(width).fill('.'));
    let ground = height - 2;
    const heights = [];
    for (let x=0; x<width; x++){
      // å³¶å‹ã®é™¸åœ°ï¼ˆä¸¡å´ãŒç©´ã®å°ã•ãªè¶³å ´ï¼‰
      if (x>2 && x<width-3 && Math.random() < 0.04){
        const islandW = Math.random() < 0.5 ? 1 : 2;
        const gap = 1;
        // å·¦ã®ç©´
        for (let g=0; g<gap && x<width; g++, x++){
          heights.push(ground);
          // ä½•ã‚‚ç½®ã‹ãšã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® '.' ã®ã¾ã¾
        }
        // å³¶æœ¬ä½“
        for (let i=0; i<islandW && x<width; i++, x++){
          heights.push(ground);
          for (let y=ground; y<height; y++) grid[y][x] = '#';
          if (Math.random() < 0.05) grid[ground-1][x] = 'o';
          if (Math.random() < 0.03) grid[ground-1][x] = '^';
          if (Math.random() < 0.02) grid[ground-1][x] = 'e';
        }
        // å³ã®ç©´
        for (let g=0; g<gap && x<width; g++, x++){
          heights.push(ground);
        }
        x--; // for ãƒ«ãƒ¼ãƒ—ã®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆåˆ†ã‚’èª¿æ•´
        continue;
      }
      // ãƒ©ãƒ³ãƒ€ãƒ ãªç©´ï¼ˆã‚¸ãƒ£ãƒ³ãƒ—ã§è¶Šãˆã‚‰ã‚Œã‚‹å¹…ï¼‰
      if (x>2 && x<width-3 && Math.random() < 0.06){
        const holeW = Math.random() < 0.5 ? 1 : 2;
        for (let i=0; i<holeW && x<width; i++, x++){
          heights.push(ground);
          // ä½•ã‚‚ç½®ã‹ãšã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® '.' ã®ã¾ã¾ã«ã™ã‚‹
        }
        x--; // for ãƒ«ãƒ¼ãƒ—ã®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆåˆ†ã‚’èª¿æ•´
        continue;
      }
      if (Math.random() < 0.3){
        ground += Math.sign(Math.random() - 0.5);
        ground = clamp(ground, 4, height-2);
      }
      heights.push(ground);
      for (let y=ground; y<height; y++) grid[y][x] = '#';
      if (Math.random() < 0.05) grid[ground-1][x] = 'o';
      if (Math.random() < 0.03) grid[ground-1][x] = '^';
      if (Math.random() < 0.02) grid[ground-1][x] = 'e';
    }
    grid[heights[1]-1][1] = 'S';
    grid[heights[width-2]-1][width-2] = 'F';
    LEVEL = grid.map(row=>row.join(''));
    mapH = LEVEL.length;
    mapW = LEVEL[0].length;
  }

  const solids = new Set(['#']);
  const hazards= new Set(['^']);
  const pickups= new Set(['o']);

  const inMap = (tx,ty)=> tx>=0 && ty>=0 && tx<mapW && ty<mapH;
  const isSolid = (tx,ty)=> inMap(tx,ty) && solids.has(LEVEL[ty][tx]);
  const isHazard= (tx,ty)=> inMap(tx,ty) && hazards.has(LEVEL[ty][tx]);

  // ===== ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ =====
  class Rect {
    constructor(x,y,w,h){ this.x=x; this.y=y; this.w=w; this.h=h; }
    get left(){return this.x;} get right(){return this.x+this.w;}
    get top(){return this.y;} get bottom(){return this.y+this.h;}
  }
  class Entity extends Rect {
    constructor(x,y,w,h){ super(x,y,w,h); this.vx=0; this.vy=0; this.rem=false; }
  }

  class Player extends Entity {
    constructor(x,y){
      super(x,y,24,24);
      this.onGround=false;
      this.jumpBuffered=0;
      this.coyote=0;
      this.jumpCount=0;
      this.facing=1;
      this.alive=true;
      this.blink=0;
    }
    update(dt){
      const speed = 160;
      const accel = 1400;
      const decc  = 1800;
      const maxFall = 900;
      const jumpV = 620;

      // è‡ªå‹•ã§å³ã«é€²ã‚€ã€‚ã‚­ãƒ¼å…¥åŠ›ã§ä½é€Ÿã€‚
      const maxSpeed = keys.slow ? 80 : 160;
      this.facing = 1;

      // æ°´å¹³é€Ÿåº¦
      if (this.vx < maxSpeed) {
        this.vx += accel * dt;
        if (this.vx > maxSpeed) this.vx = maxSpeed;
      } else if (this.vx > maxSpeed) {
        this.vx -= decc * dt;
        if (this.vx < maxSpeed) this.vx = maxSpeed;
      }
      this.vx = Math.max(0, this.vx);

      // ã‚¸ãƒ£ãƒ³ãƒ—å…¥åŠ›ãƒãƒƒãƒ•ã‚¡
      if (keys.up){ this.jumpBuffered = 0.12; keys.up=false; }
      this.jumpBuffered = Math.max(0, this.jumpBuffered - dt);
      this.coyote = Math.max(0, this.coyote - dt);

      // é‡åŠ›
      this.vy += 2000 * dt;
      this.vy = Math.min(this.vy, maxFall);

      // åœ°å½¢ã¨ã®å½“ãŸã‚Šåˆ¤å®šï¼ˆXâ†’Y ã®é †ï¼‰
      this.x += this.vx*dt;
      this.resolveCollisions(true);
      this.y += this.vy*dt;
      const wasOnGround = this.onGround;
      this.onGround = this.resolveCollisions(false);

      if (this.onGround) { this.coyote = 0.08; this.jumpCount = 0; }

      // ã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆã‚³ãƒ¨ãƒ¼ãƒ†ã‚¿ã‚¤ãƒ ï¼‹å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ï¼‰
      if (this.alive && this.jumpBuffered>0 && (this.onGround || this.coyote>0 || this.jumpCount<2)) {
        this.vy = -jumpV;
        this.onGround = false;
        this.coyote = 0;
        this.jumpBuffered = 0;
        this.jumpCount++;
        particles.jump(this.x+this.w/2, this.bottom);
      }

      // ãƒã‚¶ãƒ¼ãƒ‰åˆ¤å®š
      if (this.hitHazard()) this.die();

      // ç©´è½ä¸‹åˆ¤å®š
      if (this.bottom > mapH * TILE) this.die();

      // æ•µè¸ã¿ã¤ã‘ãƒ»æ¥è§¦
      for (const e of enemies) {
        if (e.dead) continue;
        if (aabb(this, e)) {
          // ä¸Šã‹ã‚‰è¸ã‚“ã 
          if (this.vy>0 && this.bottom - e.top < 14) {
            this.y = e.top - this.h; this.vy = -280; e.stomp();
          } else {
            this.die();
          }
        }
      }

      // ã‚³ã‚¤ãƒ³å–å¾—
      for (const c of coins) {
        if (!c.rem && aabb(this,c)) { c.rem=true; score += 10; flash('+10'); }
      }

      // ã‚´ãƒ¼ãƒ«
      if (aabb(this, flag)) {
        win();
      }

      // ç›®ãƒ‘ãƒ
      this.blink += dt;
    }

    hitHazard(){
      // è¶³å…ƒ4ç‚¹ã§ãƒˆã‚²åˆ¤å®š
      const pts = [
        [this.left+3, this.bottom-2],
        [this.right-3, this.bottom-2],
        [this.left+3, this.top+4],
        [this.right-3, this.top+4],
      ];
      for (const [px,py] of pts) {
        const tx = Math.floor(px/TILE), ty = Math.floor(py/TILE);
        if (isHazard(tx,ty)) return true;
      }
      return false;
    }

    resolveCollisions(horizontal){
      const minx = Math.floor((this.left-1)/TILE), maxx = Math.floor((this.right+1)/TILE);
      const miny = Math.floor((this.top-1)/TILE),  maxy = Math.floor((this.bottom+1)/TILE);
      let grounded=false;
      for (let ty=miny; ty<=maxy; ty++){
        for (let tx=minx; tx<=maxx; tx++){
          if (!isSolid(tx,ty)) continue;
          const bx = tx*TILE, by=ty*TILE;
          const bw=TILE, bh=TILE;
          if (this.right>bx && this.left<bx+bw && this.bottom>by && this.top<by+bh){
            // è¡çªè§£æ¶ˆ
            const dx1 = (bx+bw) - this.left;
            const dx2 = this.right - bx;
            const dy1 = (by+bh) - this.top;
            const dy2 = this.bottom - by;
            const penX = Math.min(dx1, dx2);
            const penY = Math.min(dy1, dy2);
            if (horizontal) {
              // Xç§»å‹•æ™‚ã¯Xã‚’å„ªå…ˆã—ã¦è§£æ¶ˆ
              if (penX < penY) {
                if (dx1 < dx2) this.x = bx + bw; else this.x = bx - this.w;
                this.vx = 0;
              }
            } else {
              // Yç§»å‹•æ™‚ã¯Yã‚’å„ªå…ˆ
              if (penY <= penX) {
                if (dy1 < dy2) { this.y = by + bh; this.vy = 0; }
                else { this.y = by - this.h; this.vy = 0; grounded=true; }
              }
            }
          }
        }
      }
      return grounded;
    }

    die(){
      if (!this.alive) return;
      this.alive=false;
      lives--;
      shake(8, 350);
      particles.poof(this.x+this.w/2, this.y+this.h/2, COLORS.slimeBody);
      if (lives<=0) lose();
      else respawn();
    }

    draw(){
      // ä½“ï¼ˆã·ã«ã·ã«ï¼‰
      const t = Date.now()/1000;
      const squish = clamp((Math.sin(t*6)+1)/12,0,0.1);
      const w = this.w*(1+squish), h = this.h*(1-squish);
      const cx = this.x + this.w/2, cy = this.y + this.h/2;
      roundedBlob(cx, cy, w, h, COLORS.slimeBody, COLORS.slimeBelly);

      // ç›®
      const eyeY = -3;
      const eyeX = 5 * this.facing;
      circle(cx - eyeX, cy + eyeY, 3, COLORS.slimeEye);
      circle(cx + eyeX, cy + eyeY, 3, COLORS.slimeEye);

      // ã»ã‚“ã®ã‚Šå½±
      ctx.globalAlpha = 0.15;
      ellipse(this.x+this.w/2, this.bottom+6, this.w*0.7, 5, '#000');
      ctx.globalAlpha = 1.0;
    }
  }

  class Enemy extends Entity {
    constructor(x,y){
      super(x,y,24,22);
      this.dir = Math.random()<0.5?-1:1;
      this.speed = 45 + Math.random()*35;
      this.dead = false;
    }
    update(dt){
      if (this.dead) return;
      // è¶³å…ƒã®ã‚¿ã‚¤ãƒ«ã§ç«¯ãƒã‚§ãƒƒã‚¯ã€å£ã§åè»¢
      this.vx = this.dir * this.speed;
      this.x += this.vx*dt;
      if (this.collideSolid()){ this.dir *= -1; this.x += this.dir*4; }
      // è½ä¸‹ã—ãªã„ã‚ˆã†ã«è¶³å…ƒ1ã‚¿ã‚¤ãƒ«å…ˆã‚’ç¢ºèª
      const aheadX = Math.floor((this.centerX() + this.dir*14)/TILE);
      const footY  = Math.floor((this.bottom+2)/TILE);
      if (!isSolid(aheadX, footY)) this.dir *= -1;

      // é‡åŠ›&åœ°é¢
      this.vy += 2000*dt; this.y += this.vy*dt;
      if (this.collideSolidY()){ this.vy=0; }
    }
    centerX(){ return this.x+this.w/2; }
    collideSolid(){
      const minx = Math.floor((this.left-1)/TILE), maxx = Math.floor((this.right+1)/TILE);
      const miny = Math.floor((this.top-1)/TILE),  maxy = Math.floor((this.bottom+1)/TILE);
      for (let ty=miny; ty<=maxy; ty++){
        for (let tx=minx; tx<=maxx; tx++){
          if (!isSolid(tx,ty)) continue;
          const bx = tx*TILE, by=ty*TILE;
          if (this.right>bx && this.left<bx+TILE && this.bottom>by && this.top<by+TILE){
            // X ã®ã¿è§£æ¶ˆ
            const dx1 = (bx+TILE) - this.left;
            const dx2 = this.right - bx;
            if (dx1 < dx2) this.x = bx+TILE; else this.x = bx - this.w;
            return true;
          }
        }
      }
      return false;
    }
    collideSolidY(){
      const minx = Math.floor((this.left-1)/TILE), maxx = Math.floor((this.right+1)/TILE);
      const miny = Math.floor((this.top-1)/TILE),  maxy = Math.floor((this.bottom+1)/TILE);
      for (let ty=miny; ty<=maxy; ty++){
        for (let tx=minx; tx<=maxx; tx++){
          if (!isSolid(tx,ty)) continue;
          const bx = tx*TILE, by=ty*TILE;
          if (this.right>bx && this.left<bx+TILE && this.bottom>by && this.top<by+TILE){
            const dy1 = (by+TILE) - this.top;
            const dy2 = this.bottom - by;
            if (dy1 < dy2) this.y = by+TILE; else this.y = by - this.h;
            return true;
          }
        }
      }
      return false;
    }
    stomp(){
      if (this.dead) return;
      this.dead = true; this.rem = true;
      particles.poof(this.x+this.w/2, this.y+this.h/2, COLORS.enemy);
      score += 50;
      flash('ã„ã„ã­ï¼ 50');
    }
    draw(){
      // ã·ã‚ˆæ•µ
      roundedBlob(this.x+this.w/2, this.y+this.h/2, this.w, this.h, COLORS.enemy, '#fff0');
      // ç¸å–ã‚Š
      ctx.globalAlpha=0.5; roundedRect(this.x-2,this.y-2,this.w+4,this.h+4,8, COLORS.enemyEdge, false);
      ctx.globalAlpha=1;
      // ç›®
      circle(this.x+8, this.y+8, 2.5, COLORS.slimeEye);
      circle(this.x+this.w-8, this.y+8, 2.5, COLORS.slimeEye);
    }
  }

  class Coin extends Entity {
    constructor(x,y){ super(x,y,16,16); this.t=Math.random()*Math.PI*2; }
    update(dt){ this.t+=dt*6; }
    draw(){
      const cx=this.x+8, cy=this.y+8;
      const r=6 + Math.sin(this.t)*1.5;
      circle(cx,cy,r, COLORS.coin);
      ctx.strokeStyle='#e6b84e'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(cx,cy,r*0.6,0,Math.PI*2); ctx.stroke();
    }
  }

  class Flag extends Entity {
    constructor(x,y){ super(x,y-32,18,48); }
    draw(){
      // ãƒãƒ¼ãƒ«
      roundedRect(this.x, this.y-4, 4, this.h+8, 2, COLORS.flagPole, true);
      // æ——
      const t = Date.now()/400;
      const fx = this.x+4, fy = this.y+10;
      ctx.fillStyle = COLORS.flag;
      ctx.beginPath();
      ctx.moveTo(fx, fy);
      ctx.quadraticCurveTo(fx+18 + Math.sin(t)*2, fy+6, fx, fy+12);
      ctx.closePath(); ctx.fill();
      // ã‚´ãƒ¼ãƒ«å°
      roundedRect(this.x-6, this.y+this.h-12, 24, 12, 4, COLORS.blockEdge, true);
    }
  }

  // ===== ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ =====
  const particles = {
    list: [],
    add(x,y,vx,vy,life,color,size){ this.list.push({x,y,vx,vy,life,max:life,color,size}); },
    jump(x,y){
      for (let i=0;i<10;i++){
        const a=Math.random()*Math.PI; const s=60+Math.random()*100;
        this.add(x,y, Math.cos(a)*s, -Math.abs(Math.sin(a)*s), 0.4, COLORS.slimeBody, 3);
      }
    },
    poof(x,y,color){
      for (let i=0;i<18;i++){
        const a=Math.random()*Math.PI*2; const s=80+Math.random()*120;
        this.add(x,y, Math.cos(a)*s, Math.sin(a)*s, 0.6, color, 3.5);
      }
    },
    update(dt){
      for (const p of this.list){ p.life-=dt; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy+=800*dt; }
      this.list = this.list.filter(p=>p.life>0);
    },
    draw(){
      for (const p of this.list){
        ctx.globalAlpha = Math.max(0,p.life/p.max);
        circle(p.x,p.y,p.size,p.color);
      }
      ctx.globalAlpha=1;
    }
  };

  // ===== è¡çª & æç”»ãƒ˜ãƒ«ãƒ‘ =====
  function aabb(a,b){ return a.left<b.right && a.right>b.left && a.top<b.bottom && a.bottom>b.top; }
  function roundedRect(x,y,w,h,r,fill=true){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    if (fill){ ctx.fillStyle = arguments[5] || '#000'; ctx.fill(); }
    else { ctx.strokeStyle = arguments[5] || '#000'; ctx.stroke(); }
  }
  function roundedBlob(cx,cy,w,h,color,belly){
    // æœ¬ä½“
    roundedRect(cx-w/2, cy-h/2, w, h, Math.min(12, w/3), true, color);
    // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    ctx.globalAlpha=0.35;
    ellipse(cx-w*0.15, cy-h*0.2, w*0.35, h*0.25, '#fff');
    ctx.globalAlpha=1.0;
    // ãŠè…¹
    ctx.globalAlpha=0.5;
    ellipse(cx, cy+2, w*0.6, h*0.45, belly);
    ctx.globalAlpha=1.0;
  }
  function ellipse(cx,cy,rx,ry, color){
    ctx.beginPath();
    ctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2);
    ctx.fillStyle=color; ctx.fill();
  }
  function circle(x,y,r,color){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=color; ctx.fill(); }

  // ===== ã‚«ãƒ¡ãƒ© =====
  const camera = { x:0, y:0 };
  function updateCamera(dt){
    const targetX = clamp(player.x - cv.clientWidth/2 + player.w/2, 0, mapW*TILE - cv.clientWidth);
    const targetY = clamp(player.y - cv.clientHeight/2 + player.h/2, 0, mapH*TILE - cv.clientHeight);
    camera.x += (targetX - camera.x) * Math.min(1, dt*6);
    camera.y += (targetY - camera.y) * Math.min(1, dt*6);
  }

  // ===== HUD =====
  const elScore = document.getElementById('score');
  const elLives = document.getElementById('lives');
  const elMsg   = document.getElementById('msg');
  let score = 0, lives = 3;
  function updateHUD(){
    elScore.textContent = `â˜… ${score}`;
    elLives.textContent = `â™¥ ${lives}`;
  }
  let msgTimer=0;
  function flash(text, t=1.2){
    elMsg.textContent = text;
    elMsg.style.opacity = 1;
    msgTimer = t;
  }

  // ===== ç”»é¢ã‚·ã‚§ã‚¤ã‚¯ =====
  let shakeT=0, shakeMag=0;
  function shake(mag, ms){
    shakeMag = mag; shakeT = ms/1000;
  }

  // ===== ãƒ¬ãƒ™ãƒ«ç”Ÿæˆ =====
  let player, enemies=[], coins=[], flag;
  function buildLevel(){
    enemies=[]; coins=[];
    for (let y=0;y<mapH;y++){
      for (let x=0;x<mapW;x++){
        const ch = LEVEL[y][x];
        if (ch==='S') { player = new Player(x*TILE+4, y*TILE-8); }
        else if (ch==='e'){ enemies.push(new Enemy(x*TILE+4, y*TILE-10)); }
        else if (ch==='o'){ coins.push(new Coin(x*TILE+8, y*TILE+8)); }
        else if (ch==='F'){ flag = new Flag(x*TILE+12, y*TILE-8); }
      }
    }
    if (!player) player = new Player(32, 32);
    if (!flag) flag = new Flag((mapW-3)*TILE, (mapH-2)*TILE);
  }

  function resetLevel(){
    score = 0; lives = 3; paused = false;
    generateLevel();
    buildLevel(); flash("ã‚¹ã‚¿ãƒ¼ãƒˆï¼");
  }
  function respawn(){
    // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã¸æˆ»ã™
    const px = LEVEL.flat().indexOf('S');
    const sx = LEVEL.findIndex(row=>row.includes('S'));
    // ä½ç½®ã¯ buildLevel ã¨åŒæ§˜ã«ï¼ˆç°¡æ˜“ï¼‰
    for (let y=0;y<mapH;y++){
      for (let x=0;x<mapW;x++){
        if (LEVEL[y][x]==='S'){ player.x=x*TILE+4; player.y=y*TILE-8; player.vx=0; player.vy=0; player.alive=true; return; }
      }
    }
  }
  function win(){ flash("ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†ğŸ‰"); paused=true; }
  function lose(){ flash("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼â€¦ Rã§å†æŒ‘æˆ¦"); paused=true; }

  // ===== ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— =====
  let last=0, paused=false;
  function step(ts){
    const t = ts/1000;
    if (!last) last=t;
    let dt = Math.min(0.033, t-last); last=t;

    if (!paused){
      // æ›´æ–°
      player.update(dt);
      for (const e of enemies) e.update(dt);
      for (const c of coins) c.update(dt);
      enemies = enemies.filter(e=>!e.rem);
      coins   = coins.filter(c=>!c.rem);
      particles.update(dt);
      updateCamera(dt);
      updateHUD();
      if (msgTimer>0){ msgTimer -= dt; elMsg.style.opacity = Math.max(0, msgTimer/0.6); }
    }

    // æç”»
    draw();

    requestAnimationFrame(step);
  }

  function draw(){
    const w = cv.clientWidth, h=cv.clientHeight;

    // ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯
    let sx=0, sy=0;
    if (shakeT>0){
      shakeT -= 1/60;
      const f = shakeT/0.35;
      sx = (Math.random()-0.5) * shakeMag * f;
      sy = (Math.random()-0.5) * shakeMag * f;
    }

    ctx.save();
    ctx.translate(-camera.x+sx, -camera.y+sy);

    // èƒŒæ™¯ï¼ˆã‚„ã‚ã‚‰ã‹é›²ï¼‰
    drawSky();
    drawHills();

    // ã‚¿ã‚¤ãƒ«æç”»
    for (let y=0;y<mapH;y++){
      for (let x=0;x<mapW;x++){
        const ch = LEVEL[y][x];
        const px = x*TILE, py=y*TILE;
        if (ch==='#') {
          roundedRect(px+2,py+2,TILE-4,TILE-4,8,COLORS.block,true);
          // å½±
          ctx.globalAlpha=0.08;
          roundedRect(px+4,py+6,TILE-8,TILE-8,8,'#000',true);
          ctx.globalAlpha=1;
          // ã‚¨ãƒƒã‚¸
          ctx.strokeStyle = COLORS.blockEdge; ctx.lineWidth=2;
          roundedRect(px+2,py+2,TILE-4,TILE-4,8,false);
        } else if (ch==='^'){
          // ãƒˆã‚²
          ctx.fillStyle = COLORS.spike;
          ctx.beginPath();
          ctx.moveTo(px+4, py+TILE-4);
          ctx.lineTo(px+TILE/2, py+6);
          ctx.lineTo(px+TILE-4, py+TILE-4);
          ctx.closePath(); ctx.fill();
        }
      }
    }

    // ã‚³ã‚¤ãƒ³ãƒ»æ•µãƒ»æ——ãƒ»ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    for (const c of coins) c.draw();
    for (const e of enemies) e.draw();
    flag.draw();
    player.draw();
    particles.draw();

    ctx.restore();

    // å‰æ™¯ã®æŸ”ã‚‰ã‹ã„å…‰
    ctx.globalAlpha=0.12;
    ctx.fillStyle='#ffffff';
    ctx.fillRect(0,0,cv.clientWidth,cv.clientHeight);
    ctx.globalAlpha=1;
  }

  function drawSky(){
    // ãµã‚ãµã‚é›²
    const off = (Date.now()/4000)%10000;
    for (let i=0;i<6;i++){
      const x = (i*300 - (camera.x*0.2 + off))% (mapW*TILE);
      const y = 40 + (i%3)*30;
      cloud(x, y, 80+ i*10, 22+ i*2);
    }
  }
  function cloud(x,y,w,h){
    ctx.globalAlpha=0.25; ellipse(x,y,w,h,'#fff');
    ellipse(x+w*0.4,y-6,w*0.8,h*0.9,'#fff');
    ellipse(x-w*0.2,y-4,w*0.6,h*0.8,'#fff');
    ctx.globalAlpha=1;
  }
  function drawHills(){
    // å¥¥ã®ã‚†ã‚‹ä¸˜
    ctx.globalAlpha=0.25;
    ctx.fillStyle='#bfefff';
    const baseY = mapH*TILE-60;
    ctx.beginPath();
    ctx.moveTo(-1000, baseY);
    for (let x= -1000; x< mapW*TILE+1000; x+=80){
      const y = baseY - 10*Math.sin((x+camera.x)*0.001) - 18*Math.sin((x+camera.x)*0.0004);
      ctx.lineTo(x,y);
    }
    ctx.lineTo(mapW*TILE+1000, baseY+400);
    ctx.lineTo(-1000, baseY+400);
    ctx.closePath(); ctx.fill();
    ctx.globalAlpha=1;
  }

  // ===== ã‚¹ã‚¿ãƒ¼ãƒˆï¼ =====
  generateLevel();
  buildLevel();
  requestAnimationFrame(step);

})();
</script>
</body>
</html>
